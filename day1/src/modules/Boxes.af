
/*
 * A module for creating safe boxes for primitive types.
 */
.needs <std>

safe dynamic class Int {
    private int value = value;
    private int refCount = 1;

    /*
     * A safe wrapper for the primitive type int 
     * can be used with generics like `new List(Int)` 
     * because it is a dynamic class, It must be initialized with `new Int(value)`
     */
    Int init(int value) {
        return my;
    };

    // pass by reference
    Int get() {
        my.refCount = my.refCount + 1;
        return my;
    };

    // copy
    Int copy() {
        return new Int(my.value);
    };

    int getVal() {
        return my.value;
    };

    bool isUnique() {
        return my.refCount == 1;
    };

    int release() {
        my.refCount = my.refCount - 1;
        if my.refCount == 0 {
            delete my;
        };
    };

        // operators
    bool equals<<==>>(Int other) {
        bool res = my.value == other.value;
        other.release();
        return res;
    };

    bool notEquals<<!=>>(Int other) {
        bool res = my.value != other.value;
        other.release();
        return res;
    };

    bool lessThan<<<>>(Int other) {
        bool res = my.value < other.value;
        other.release();
        return res;
    };

    bool greaterThan<<>>>>(Int other) {
        bool res = my.value > other.value;
        other.release();
        return res;
    };

    Int add<<+>>(Int other) {
        int val = my.value + other.value;
        other.release();
        return new Int(val);
    };

    Int sub<<->>(Int other) {
        int val = my.value - other.value;
        other.release();
        return new Int(val);
    };

    Int mul<<*>>(Int other) {
        int val = my.value * other.value;
        other.release();
        return new Int(val);
    };

    Int div<</>>(Int other) {
        int val = my.value / other.value;
        other.release();
        return new Int(val);
    };

    int assign<<=>>(Int other) {
        my.value = other.value;
        other.release();
    };

    Int endScope() { // called when the object goes out of scope of a block
        return my.release();
    };
};

safe dynamic class Long {
    private long value = value;
    private int refCount = 1;

    Long init(long value) {
        return my;
    };

    // pass by reference
    Long get() {
        my.refCount = my.refCount + 1;
        return my;
    };

    // copy
    Long copy() {
        return new Long(my.value);
    };

    long getVal() {
        return my.value;
    };

    bool isUnique() {
        return my.refCount == 1;
    };

    int release() {
        my.refCount = my.refCount - 1;
        if my.refCount == 0 {
            delete my;
        };
    };

        // operators
    bool equals<<==>>(Long other) {
        bool res = my.value == other.value;
        other.release();
        return res;
    };

    bool notEquals<<!=>>(Long other) {
        bool res = my.value != other.value;
        other.release();
        return res;
    };

    bool lessThan<<<>>(Long other) {
        bool res = my.value < other.value;
        other.release();
        return res;
    };

    bool greaterThan<<>>>>(Long other) {
        bool res = my.value > other.value;
        other.release();
        return res;
    };

    bool assign<<=>>(Long other) {
        my.value = other.value;
        other.release();
    };

    Long add<<+>>(Long other) {
        long val = my.value + other.value;
        other.release();
        return new Long(val);
    };

    Long sub<<->>(Long other) {
        long val = my.value - other.value;
        other.release();
        return new Long(val);
    };

    Long mul<<*>>(Long other) {
        long val = my.value * other.value;
        other.release();
        return new Long(val);
    };

    Long div<</>>(Long other) {
        long val = my.value / other.value;
        other.release();
        return new Long(val);
    };

    int endScope() { // called when the object goes out of scope of a block
        return my.release();
    };
};

safe dynamic class Adr {
    private adr value = value;
    private int refCount = 1;

    Adr init(adr value) {
        return my;
    };

    // pass by reference
    Adr get() {
        my.refCount = my.refCount + 1;
        return my;
    };

    // copy
    Adr copy() {
        return new Adr(my.value);
    };

    adr getVal() {
        return my.value;
    };

    bool isUnique() {
        return my.refCount == 1;
    };

    int release() {
        my.refCount = my.refCount - 1;
        if my.refCount == 0 {
            delete my;
        };
    };

    // operators
    bool equals<<==>>(Adr other) {
        bool res = my.value == other.value;
        other.release();
        return res;
    };

    bool notEquals<<!=>>(Adr other) {
        bool res = my.value != other.value;
        other.release();
        return res;
    };

    bool lessThan<<<>>(Adr other) {
        bool res = my.value < other.value;
        other.release();
        return res;
    };

    bool greaterThan<<>>>>(Adr other) {
        bool res = my.value > other.value;
        other.release();
        return res;
    };

    bool assign<<=>>(Adr other) {
        my.value = other.value;
        other.release();
    };

    int endScope() { // called when the object goes out of scope of a block
        return my.release();
    };
};
